# -*- python -*-
# ex: set filetype=python:

from buildbot.process.build import Build
from buildbot.plugins import *
from buildbot import locks
from twisted.python import log
import buildbot
import subprocess, re, json


f = open('config.json', 'r')
config = json.loads(f.read ())

def getConfig(name, default=""):
    if config.has_key(name):
        return config[name].encode('ascii', 'ignore')
    return default

def getConfigv(name, default=[]):
    if config.has_key(name):
        res = []
        for i in config[name]:
            res.append(i.encode('ascii', 'ignore'))
        return res
    return default

flathub_github_uri = getConfig('github-uri')
flathub_buildbot_uri = getConfig('buildbot-uri')
flathub_upstream_repo = getConfig('flathub-repo')
flathub_upstream_repo_path = getConfig('flathub-repo-path')
flathub_branch = getConfig('flathub-branch')
flathub_gpg_homedir = getConfig('flathub-gpg-homedir')
flathub_gpg_key = getConfig('flathub-gpg-key')
flathub_admin_password = getConfig('admin-password')
flathub_github_auth_client = getConfig('github-auth-client')
flathub_github_auth_secret = getConfig('github-auth-secret')
flathub_github_auth_admin_emails = getConfigv('github-auth-emails')
flathub_github_change_secret = getConfig('github-change-secret')
flathub_github_status_token = getConfig('github-status-token')

f = open('builders.json', 'r')
worker_config = json.loads(f.read ())

###### Init

c = BuildmasterConfig = {}
c['change_source'] = []
c['protocols'] = {}

####### Authentication

auth = None
roleMatchers=[]

if flathub_admin_password != '':
    auth = util.UserPasswordAuth({"admin": flathub_admin_password})
    roleMatchers.append(util.RolesFromEmails(admins=["admin"]))

if flathub_github_auth_client != '':
    auth = util.GitHubAuth(flathub_github_auth_client, flathub_github_auth_secret)
    roleMatchers.append(util.RolesFromEmails(admins=flathub_github_auth_admin_emails))

authz = util.Authz(
    allowRules=[
        util.RebuildBuildEndpointMatcher(role="admins", defaultDeny=True),
        util.StopBuildEndpointMatcher(role="admins", defaultDeny=True),
        util.ForceBuildEndpointMatcher(role="admins", defaultDeny=True),
        util.EnableSchedulerEndpointMatcher(role="admins", defaultDeny=True)
    ],
    roleMatchers=roleMatchers
)

c['protocols']['pb'] = {'port': 9989}

####### SETUP

flathub_arches = []
flathub_arch_workers = {}
flathub_checkin_workers = []
flathub_update_workers = []

gpg_args = []
if flathub_gpg_key:
    gpg_args.append ('--gpg-sign=' + flathub_gpg_key)
if flathub_gpg_homedir:
    gpg_args.append ('--gpg-homedir=' + flathub_gpg_homedir)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = []

for w in worker_config.iterkeys():
    wc = worker_config[w]
    w = w.encode('ascii', 'ignore')
    passwd = wc[u'password'].encode('ascii', 'ignore')
    c['workers'].append (worker.Worker(w, passwd))
    if wc.has_key(u'arches'):
        for a in wc[u'arches']:
            a = a.encode('ascii', 'ignore')
            if not a in flathub_arches:
                flathub_arches.append(a)
                flathub_arch_workers[a] = []
                flathub_arch_workers[a].append(w)
    if wc.has_key(u'checkin'):
        flathub_checkin_workers.append(w)
    if wc.has_key(u'update-repo'):
        flathub_update_workers.append(w)


####### SCHEDULERS

checkin = schedulers.AnyBranchScheduler(name="checkin",
                                        treeStableTimer=None,
                                        builderNames=["checkin"])
build = schedulers.Triggerable(name="build-all-platforms",
                               builderNames=map(lambda x: "build-" + x, flathub_arches))
update_repo = schedulers.Triggerable(name="update-repo",
                                     builderNames=["update-repo"])

force = schedulers.ForceScheduler(
    name="force",
    buttonName="Rebuild",
    label="Force a rebuild",
    builderNames=["checkin"],

    codebases=[
        util.CodebaseParameter(
            "",
            name="Main repository",
            branch=util.StringParameter(name="branch",
                                        label="app:",
                                        required=True),
            revision=util.FixedParameter(name="revision", default=""),
            repository=util.FixedParameter(name="repository", default=""),
            project=util.FixedParameter(name="project", default=""),
        ),
    ],
    reason=util.StringParameter(name="reason",
                                label="reason:",
                                required=True, size=80)
)

c['schedulers'] = [checkin, build, update_repo, force]
c['collapseRequests'] = False

####### Custom builders

# This is a build class that automatically takes a per-branch lock
# which means only one build of a branch can be outstanding at a time
class BranchLockBuild(Build):
    _masterLocks = {}

    @staticmethod
    def find_or_create_master_lock_for_branch(branch):
        lock = BranchLockBuild._masterLocks.get(branch)
        if lock is None:
            log.msg("********* Created lock for branch %s" % branch)
            lock = locks.MasterLock(branch + ' branch')
            BranchLockBuild._masterLocks[branch] = lock
        return lock

    def startBuild(self, build_status, workerforbuilder):
        if self.sources and len(self.sources) == 1:
            branch = self.sources[0].branch
            lock = BranchLockBuild.find_or_create_master_lock_for_branch(branch)
            self.setLocks([lock.access('exclusive')])
        return Build.startBuild(self, build_status, workerforbuilder)

####### BUILDERS

flatpak_update_lock = util.WorkerLock("flatpak-update")
repo_lock = util.MasterLock("repo")

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

build_factory = util.BuildFactory()
build_factory.workdir = util.Interpolate('build-%(prop:branch)s')
build_factory.addStep(steps.Git(name="checkout manifest",
                                repourl=flathub_github_uri,
                                mode='incremental', branch=util.Property('branch')))
build_factory.addStep(steps.FileDownload(name='downloading public key',
                                         mastersrc="flathub.gpg",
                                         workerdest="flathub.gpg"))
build_factory.addStep(steps.ShellSequence(name='initializing repos',
                                          haltOnFailure=True,
                                          commands=[
                                              util.ShellArg(command=['rm', '-rf', 'parent-repo', 'repo', 'repo.tar']),
                                              util.ShellArg(command=['ostree', '--repo=parent-repo', '--mode=archive-z2', 'init']),
                                              util.ShellArg(command=['ostree', '--repo=parent-repo', 'remote', 'add', '--gpg-import=flathub.gpg', 'upstream', flathub_upstream_repo]),
                                              util.ShellArg(command=['ostree', '--repo=repo', '--mode=archive-z2', 'init'])
                                          ]))
build_factory.addStep(steps.ShellCommand(name='set core.parent',
                                         command=['ostree', '--repo=repo', 'config', 'set', 'core.parent', util.Interpolate('%(prop:builddir)s/build-%(prop:branch)s/parent-repo')]))
build_factory.addStep(steps.ShellCommand(name='pull current revision into parent repo',
                                         flunkOnFailure=False, # TODO: Instead only do this if this is the first build
                                         command=['ostree', '--repo=parent-repo', 'pull', '--mirror', 'upstream',
                                                  util.Interpolate('app/%(prop:branch)s/%(prop:arch)s/' + flathub_branch),
                                                  util.Interpolate('runtime/%(prop:branch)s.Debug/%(prop:arch)s/' + flathub_branch),
                                                  util.Interpolate('runtime/%(prop:branch)s.Locale/%(prop:arch)s/' + flathub_branch)]))
build_factory.addStep(steps.ShellCommand(name='adding flathub remote',
                                         haltOnFailure=True,
                                         command=['flatpak', '--user', 'remote-add', '--if-not-exists', '--gpg-import=flathub.gpg', 'flathub', flathub_upstream_repo]))
build_factory.addStep(steps.ShellCommand(name='updating dependencies',
                                         haltOnFailure=True,
                                         locks=[flatpak_update_lock.access('exclusive')],
                                         command=['python', '-c',
"""
import sys, json, re, subprocess
j = json.loads(re.sub( r'/\*.*?\*/', '', open(sys.argv[1], 'r').read()))
runtime = j['runtime']
sdk = j['sdk']
version = j['runtime-version']
arch = sys.argv[2]
platform_ref = '%s/%s/%s' % (runtime, arch, version)
sdk_ref = '%s/%s/%s' % (sdk, arch, version)
deps = [platform_ref, sdk_ref]
for ref in deps:
  if subprocess.call(['flatpak', 'install', '--user', 'flathub', ref]) != 0:
    if subprocess.call(['flatpak', 'update', '--user', ref]):
      sys.exit(1)
""",
                                                  util.Interpolate('%(prop:branch)s.json'),
                                                  util.Property('arch')]))
build_factory.addStep(steps.ShellCommand(name='build manifest',
                                         haltOnFailure=True,
                                         command=['flatpak-builder', '--force-clean', '--sandbox',
                                                  '--arch', util.Property('arch'), '--repo', 'repo',
                                                  '--default-branch', flathub_branch,
                                                  '--subject', util.Interpolate('Build %(prop:branch)s at %(prop:revision)s'),
                                                  'builddir', util.Interpolate('%(prop:branch)s.json')]))
build_factory.addStep(steps.ShellCommand(name='check that the right branch was built',
                                         haltOnFailure=True,
                                         command=['stat', util.Interpolate('repo/refs/heads/app/%(prop:branch)s/%(prop:arch)s/' + flathub_branch)]))
build_factory.addStep(steps.ShellCommand(name='generating deltas',
                                         haltOnFailure=True,
                                         command=['flatpak', 'build-update-repo', '--generate-static-deltas', 'repo']))
build_factory.addStep(steps.ShellCommand(name='unset core.parent',
                                         command=['ostree', '--repo=repo', 'config', 'set', 'core.parent', '']))
build_factory.addStep(steps.ShellCommand(name='packaging result',
                                         haltOnFailure=True,
                                         command=['tar', 'cf', 'repo.tar', 'repo']))
build_factory.addStep(steps.FileUpload(workersrc='repo.tar',
                                       haltOnFailure=True,
                                       masterdest=util.Interpolate('builds/%(prop:branch)s-%(prop:revision)s/%(prop:arch)s-repo.tar'),
                                       blocksize=64*1024))
build_factory.addStep(steps.ShellCommand(name='clean up',
                                         alwaysRun=True,
                                         command=['rm', '-rf', '.flatpak-builder/build', 'builddir', 'repo', 'parent-repo']))

update_repo_factory = util.BuildFactory()
update_repo_factory.addStep(steps.ShellCommand(name='clean old repo', command=['rm', '-rf', 'repo']))
for arch in flathub_arches:
    update_repo_factory.addStep(steps.FileDownload(name='download ' + arch + ' build result',
                                                   mastersrc=util.Interpolate('builds/%(prop:branch)s-%(prop:revision)s/'+arch+'-repo.tar'),
                                                   workerdest=arch+'-repo.tar',
                                                   blocksize=64*1024))
    update_repo_factory.addStep(steps.ShellCommand(name='extract ' + arch + ' build result',
                                                   command=['tar', 'xf', arch+'-repo.tar']))
    update_repo_factory.addStep(steps.ShellCommand(name='remove ' + arch + ' build result archive',
                                                   command=['rm', arch+'-repo.tar']))
update_repo_factory.addStep(steps.MasterShellCommand(name='remove build results from master',
                                                     command=['rm', '-rf', util.Interpolate('builds/%(prop:branch)s-%(prop:revision)s')],
                                                     alwaysRun=True))
update_repo_factory.addStep(steps.ShellCommand(name='Ensure files are readable', command=['chmod', '-R', 'a+rX', 'repo']))
update_repo_factory.addStep(steps.ShellCommand(name='fsck results', command=['ostree', '--repo=repo', 'fsck']))
update_repo_factory.addStep(steps.ShellCommand(name='sign commits',
                                               command=['flatpak', 'build-sign'] + gpg_args +  ['repo']))
update_repo_factory.addStep(steps.ShellCommand(name='rsync objects and deltas',
                                               command=['rsync', '-rltv', '--ignore-existing',
                                                        '--include=/objects',
                                                        '--include=/objects/**',
                                                        '--include=/deltas',
                                                        '--include=/deltas/**',
                                                        '--exclude=*',
                                                        'repo/', flathub_upstream_repo_path + '/']))
update_repo_factory.addStep(steps.ShellCommand(name='syncfs',
                                               command=['sync']))
update_repo_factory.addStep(steps.ShellCommand(name='rsync refs',
                                               command=['rsync', '-rltv',
                                                        '--include=/refs',
                                                        '--include=/refs/heads',
                                                        '--include=/refs/heads/app',
                                                        '--include=/refs/heads/app/**',
                                                        '--include=/refs/heads/runtime',
                                                        '--include=/refs/heads/runtime/**',
                                                        '--exclude=*',
                                                        'repo/', flathub_upstream_repo_path + '/'],
                                               locks=[repo_lock.access('exclusive')]))
update_repo_factory.addStep(steps.ShellCommand(name='update the repo',
                                               command=['flatpak', 'build-update-repo'] + gpg_args + [flathub_upstream_repo_path],
                                               locks=[repo_lock.access('exclusive')]))

checkin_factory = util.BuildFactory()
checkin_factory.buildClass = BranchLockBuild
checkin_factory.addStep(steps.MasterShellCommand(name="Clean up storage on master",
                                                 haltOnFailure=True,
                                                 command=['rm', '-rf', util.Interpolate('builds/%(prop:branch)s-%(prop:revision)s')]))
checkin_factory.addStep(steps.Trigger(name='Build all platforms',
                                      haltOnFailure=True,
                                      schedulerNames=['build-all-platforms'],
                                      updateSourceStamp=True,
                                      waitForFinish=True))
checkin_factory.addStep(steps.Trigger(name='Update repository',
                                      haltOnFailure=True,
                                      schedulerNames=['update-repo'],
                                      updateSourceStamp=True,
                                      waitForFinish=True))

c['builders'] = []

for arch in flathub_arches:
    c['builders'].append(
        util.BuilderConfig(name='build-' + arch,
                           workernames=flathub_arch_workers[arch],
                           properties={'arch': arch},
                           factory=build_factory))
c['builders'].append(
    util.BuilderConfig(name='update-repo',
                       workernames=flathub_update_workers,
                       factory=update_repo_factory))
c['builders'].append(
    util.BuilderConfig(name='checkin',
                       collapseRequests=True,
                       workernames=flathub_checkin_workers,
                       factory=checkin_factory))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

c['services'] = []

if flathub_github_status_token != '':
    c['services'].append(reporters.GitHubStatusPush(token=flathub_github_status_token,
                                                    context=util.Interpolate("buildbot/%(prop:buildername)s"),
                                                    startDescription='Build started.',
                                                    endDescription='Build done.'))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = 'Flathub'
c['titleURL'] = 'https://github.com/flatpak/flathub'

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = flathub_buildbot_uri

c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}),
                authz=authz)
if auth:
    c['www']['auth'] = auth

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

if flathub_github_change_secret != "":
    c['www']['change_hook_dialects'] = {
        'github': {
            'secret': flathub_github_change_secret,
            'strict': True
        }
    }
else:
    c['change_source'].append(changes.GitPoller(
        flathub_github_uri,
        workdir='gitpoller-workdir', branches=True,
        pollinterval=300))

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
